---
name: 课程导入功能说明
overview: 说明如何导入MIDI文件创建课程，以及如何将多个课程组织成课程集（Course）
todos: []
---

# 课程导入功能说明

| 版本 | 日期 | 变更内容 | 变更人 |

|------|------|----------|--------|

| 1.0.0 | 2025-12-18 | 增补：MIDI识别/手动映射/校准与音乐效果校准 | 大象 |

## 当前实现状态

项目已经实现了完整的课程导入功能，包括：

1. **MIDI文件导入** (`ContentManager.importMIDIFile`)

   - 支持多种格式：`.mid`, `.midi`, `.json`, `.xml`, `.gp5`, `.gp4`, `.ptb`, `.tux`
   - 自动解析MIDI数据并转换为课程（Lesson）
   - 自动计算难度、生成标签、创建练习步骤

2. **课程创建界面** (`ContentCreationView`)

   - 提供MIDI文件导入按钮
   - 提供课程集（Course）创建功能
   - 显示导入进度和结果

3. **课程集创建** (`ContentManager.createCourse`)

   - 将多个已导入的课程组织成课程集
   - 自动计算课程集难度和标签

## 导入流程

### 方式一：通过UI界面导入

1. **打开内容创建界面**

   - 在 `ContentBrowserView` 中点击右上角的 "+" 按钮
   - 或直接访问 `ContentCreationView`

2. **导入MIDI文件**

   - 点击 "Import MIDI Files" 按钮
   - 选择MIDI文件（支持多选）
   - 系统自动解析并创建课程

3. **创建课程集（可选）**

   - 点击 "Create Course" 按钮
   - 输入课程集标题和描述
   - 选择已导入的课程
   - 点击 "Create" 完成

### 方式二：通过代码导入

```swift
// 1. 创建ContentManager实例
let contentManager = ContentManager(coreDataManager: CoreDataManager.shared)

// 为了让示例更像“可运行代码”，先声明 lessons
var lessons: [Lesson] = []

// 2. 导入单个MIDI文件
let midiURL = URL(fileURLWithPath: "/path/to/your/file.mid")
do {
    if let lesson = try await contentManager.importMIDIFile(midiURL) {
        print("课程导入成功: \(lesson.title)")
    }
} catch {
    print("导入失败: \(error)")
}

// 3. 批量导入多个MIDI文件
let midiURLs = [URL(fileURLWithPath: "/path/to/file1.mid"),
                URL(fileURLWithPath: "/path/to/file2.mid")]
do {
    lessons = try await contentManager.importMultipleMIDIFiles(midiURLs)
    print("成功导入 \(lessons.count) 个课程")
} catch {
    print("批量导入失败: \(error)")
}

// 4. 创建课程集
let course = contentManager.createCourse(
    title: "基础鼓练习",
    lessons: lessons
)
```

## 支持的文件格式

- **MIDI标准格式**: `.mid`, `.midi`
- **JSON格式**: `.json` (自定义鼓谱格式)
- **MusicXML**: `.xml`
- **Guitar Pro**: `.gp5`, `.gp4`
- **PowerTab**: `.ptb`
- **TuxGuitar**: `.tux`

## MIDI音符识别机制：如何区分Kick和Snare

系统使用**标准GM（General MIDI）鼓映射**来识别不同的鼓件。识别过程如下：

### 1. MIDI通道过滤

在 `MIDIParser.swift` 的 `extractDrumEvents` 方法中：

```swift
case .noteOn(let channel, let note, let velocity):
    // Channel 9 (0-indexed) 是标准的鼓通道
    if channel == 9 && velocity > 0 {
        activeNotes[note] = (timestamp: timestamp, velocity: Int(velocity))
    }
```

- **只处理通道9（MIDI通道10）**：这是GM标准中专门用于鼓的通道
- **过滤velocity=0的事件**：velocity=0的Note On事件实际上表示Note Off

### 2. 标准GM鼓映射表

系统使用以下映射规则识别鼓件（定义在 `ContentManager.mapMIDINoteToDrumLane` 和 `MIDIParser.getDrumKitMapping`）：

| MIDI音符编号 | 鼓件名称 | 应用内标识 |

|------------|---------|-----------|

| 35 | Bass Drum 2 | KICK |

| **36** | **Bass Drum 1** | **KICK** |

| 37 | Side Stick | - |

| **38** | **Snare Drum 1** | **SNARE** |

| 39 | Hand Clap | CLAP |

| **40** | **Snare Drum 2** | **SNARE** |

| 41, 43 | Low Tom | LO_TOM |

| **42** | **Closed Hi-hat** | **HI_HAT** |

| 45, 47 | Mid Tom | MID_TOM |

| **46** | **Open Hi-hat** | **OPEN_HI_HAT** |

| 48, 50 | High Tom | HI_TOM |

| **49** | **Crash Cymbal 1** | **CRASH** |

| 51 | Ride Cymbal 1 | - |

### 3. 识别流程

```swift
// ContentManager.swift - mapMIDINoteToDrumLane
private func mapMIDINoteToDrumLane(_ noteNumber: Int) -> String {
    switch noteNumber {
    case 36: return "KICK"           // Bass Drum 1
    case 35: return "KICK"           // Bass Drum 2 (替代)
    case 38, 40: return "SNARE"      // Snare Drum 1 & 2
    case 42: return "HI_HAT"         // Closed Hi-Hat
    case 46: return "OPEN_HI_HAT"    // Open Hi-Hat
    case 39: return "CLAP"           // Hand Clap
    case 49: return "CRASH"          // Crash Cymbal
    case 41, 43: return "LO_TOM"     // Low Tom
    case 45, 47: return "MID_TOM"    // Mid Tom
    case 48, 50: return "HI_TOM"     // High Tom
    default: return "OTHER"
    }
}
```

### 4. 完整识别流程

1. **解析MIDI文件** → 提取所有音符事件
2. **通道过滤** → 只保留通道9的事件
3. **音符映射** → 根据音符编号查找对应的鼓件
4. **创建TargetEvent** → 转换为应用内部的TargetEvent格式

### 5. 为什么使用GM标准？

- **通用性**：几乎所有MIDI鼓文件都遵循GM标准
- **兼容性**：与主流DAW（如Logic Pro, Ableton Live）兼容
- **可预测性**：音符36总是Kick，音符38总是Snare

### 6. 特殊情况处理

- **多个音符映射到同一鼓件**：如音符35和36都映射到KICK
- **未知音符**：映射到"OTHER"，不会导致错误
- **非标准映射**：如果MIDI文件使用了非标准映射，可能需要手动调整

## 如何手动调整MIDI映射

当MIDI文件使用非标准映射时（例如Kick不是音符36），可以通过以下方式手动调整：

### 关键前提：打分系统的匹配依据（非常重要）

当前 `ScoreEngine` **只用 `noteNumber` 做匹配**（`target.noteNumber == event.noteNumber`）。这意味着：

- **只调整 `Conductor.currentMidiMapping`（用于“发声”）是不够的**：如果你的MIDI设备输出的Kick不是36，而导入的谱面（TargetEvent）仍然是36，那么打分会把你的Kick当成“extra/miss”。  
- **推荐做法（更稳）**：把“用户输入的MIDI noteNumber”在进入 `ScoreEngine` 前**归一化为内部标准（Canonical noteNumber）**。例如内部统一用GM：KICK=36、SNARE=38…  
  - 设备非GM → 先用 `currentMidiMapping` 把输入note识别成鼓件（drumName），再把鼓件映射成内部GM noteNumber，最后把这个“标准noteNumber”的事件送进 `ScoreEngine`。  
  - 这样你导入的GM谱面无需改，打分也能正确工作。

### 方式一：通过代码调整（开发者模式）

```swift
// 1. 获取Conductor实例
let conductor = Conductor()

// 2. 创建自定义映射
let customMapping = MIDIMapping(
    drumPadMappings: [
        "KICK": 35,      // 改为音符35
        "SNARE": 40,     // 改为音符40
        "HI_HAT": 42,    // 保持默认
        "OPEN_HI_HAT": 46,
        "CLAP": 39,
        "LO_TOM": 43,
        "HI_TOM": 50,
        "CRASH": 49
    ],
    velocityCurve: .linear  // 可选：logarithmic, exponential
)

// 3. 应用映射
conductor.updateMIDIMapping(customMapping)

// 4. 验证映射完整性
let isValid = conductor.validateMIDIMapping()
print("映射有效性: \(isValid)")
```

### 方式二：通过配置文件调整（推荐）

映射配置会自动保存到 `UserDefaults`，可以通过以下方式修改：

```swift
// 1. 读取当前映射
let defaults = UserDefaults.standard
if let data = defaults.data(forKey: "MIDIMapping"),
   let mapping = try? JSONDecoder().decode(MIDIMapping.self, from: data) {
    print("当前映射: \(mapping.drumPadMappings)")
}

// 2. 修改映射（示例：将Kick改为音符35）
var newMapping = MIDIMapping.defaultMapping()
newMapping.drumPadMappings["KICK"] = 35

// 3. 保存映射
if let encoded = try? JSONEncoder().encode(newMapping) {
    defaults.set(encoded, forKey: "MIDIMapping")
}

// 4. 重新加载
conductor.loadSavedMIDIMapping()
```

### 方式三：创建MIDI映射配置界面（待实现）

**当前状态**：代码中已有底层支持（`MIDIMapping` 数据结构和 `updateMIDIMapping` 方法），但**缺少用户界面**。

**建议实现**：在 `SettingsView` 中添加 "MIDI Mapping" 配置页面：

```swift
// 在 SettingsView 中添加
Section("MIDI Configuration") {
    NavigationLink("MIDI Mapping") {
        MIDIMappingEditorView()
    }
    
    Button("Reset to Default Mapping") {
        conductor.updateMIDIMapping(MIDIMapping.defaultMapping())
    }
    
    Toggle("Auto-detect MIDI devices", isOn: $settingsManager.autoDetectMIDI)
}
```

**界面功能建议**：

1. **映射编辑器**

   - 显示所有鼓件和对应的MIDI音符
   - 支持点击修改音符编号
   - 实时预览：点击鼓件触发声音

2. **MIDI学习模式**

   - 点击"学习"按钮
   - 击打物理鼓垫
   - 自动捕获MIDI音符并映射

3. **预设管理**

   - 保存自定义映射预设
   - 加载常见鼓设备预设（Roland, Yamaha等）

4. **映射验证**

   - 检查映射完整性
   - 高亮未映射的鼓件
   - 显示冲突（多个鼓件映射到同一音符）

### 方式四：修改ContentManager映射逻辑（针对导入）

如果需要在导入时使用非标准映射，修改 `ContentManager.swift`：

```swift
// 在 mapMIDINoteToDrumLane 方法中添加自定义规则
private func mapMIDINoteToDrumLane(_ noteNumber: Int) -> String {
    // 优先使用用户自定义映射
    if let customMapping = UserDefaults.standard.data(forKey: "CustomImportMapping"),
       let mapping = try? JSONDecoder().decode([Int: String].self, from: customMapping),
       let drumLane = mapping[noteNumber] {
        return drumLane
    }
    
    // 回退到标准GM映射
    switch noteNumber {
    case 36: return "KICK"
    case 38, 40: return "SNARE"
    // ... 其他映射
    default: return "OTHER"
    }
}
```

### 常见MIDI鼓设备的非标准映射

| 设备品牌 | Kick音符 | Snare音符 | 备注 |

|---------|----------|-----------|------|

| Roland TD-17 | 36 | 38 | 标准GM |

| Yamaha DTX | 36 | 38 | 标准GM |

| Alesis Nitro | 35 | 38 | Kick使用35 |

| 自定义电鼓 | 需检测 | 需检测 | 使用学习模式 |

### 调试技巧

```swift
// 1. 打印当前映射（用于核对“哪个鼓件映射到哪个note”）
print("当前MIDI映射:")
for (drum, note) in conductor.currentMidiMapping.drumPadMappings {
    print("  \(drum) -> 音符\(note)")
}

// 2. 观察实际输入noteNumber（推荐做法）
// - 直接用真机连接MIDI设备，击打鼓垫
// - 在 Conductor.swift 的 handleMIDINoteOn(...) 内增加日志或断点（该方法目前是 private）
// - 看到 noteNumber/velocity 后再回到映射表调整
```

## 如何校准MIDI与对应的音乐效果（推荐流程）

下面把“校准”拆成两个维度：**打得到/打得准**（MIDI输入链路）与 **听起来对/听起来舒服**（音色与效果器链路）。

### 0. 先确定一个内部标准（Canonical）

为了让**导入谱面、实时打击、打分**三者一致，建议明确一个内部标准：

- **建议内部统一使用GM noteNumber 作为 Canonical**（例如 KICK=36，SNARE=38/40，HI_HAT=42…）
- **设备侧可任意**：靠 `currentMidiMapping` 把设备note识别成鼓件，再转换成Canonical后进入 `ScoreEngine`

> 这样做的好处：导入的MIDI（大概率GM）不用动；更换设备只要重新“学习映射”，打分仍然一致。

### 1. MIDI映射校准（Learn / 手动映射）

目标：解决“哪个note代表哪个鼓件”。

- **做法A（推荐）**：做一个“学习模式”界面（方案里已提）：选择目标鼓件（KICK/SNARE…）→ 用户击打一次 → 捕获 noteNumber → 写入 `currentMidiMapping`  
- **做法B（临时）**：用日志/断点观察设备输出noteNumber，再按“方式一/方式二”改映射

校准结束的验收：每个鼓件都能稳定触发对应发声（`Conductor.playPad`）且不会串音。

### 2. MIDI时序校准（对齐打分/伴奏/节拍器）

目标：解决“我明明跟上节拍了，但打分总是Early/Late”的问题。

- **需要一个可配置的时间偏移**（建议命名：`midiTimingOffsetMs`）  
  - 应用在 `ScoreEngine.processUserInput` 的 `timestamp` 上：`adjusted = raw + offset`
- **校准方法（可实现为校准向导）**：  
  - 开启节拍器（固定BPM）  
  - 让用户连续击打某个鼓件（例如SNARE）对齐每拍  
  - 记录每次击打与“理论拍点”的时间差，取均值/中位数 → 写入 `midiTimingOffsetMs`

> 备注：当前代码里有“音频延迟补偿/测试”相关UI，但它更偏向“听到声音的延迟”。**打分偏移**建议单独校准并存储。

### 3. 力度（Velocity）校准（听感与一致性）

目标：解决“轻打没声/重打爆音/不同鼓垫力度不均衡”的问题。

- **输入侧**：采集每个鼓垫的velocity分布（最小/最大/常用区间）  
- **映射侧**：提供曲线（linear/log/exp）+ 可选每Pad增益（gain）  
- **输出侧**：结合 `PadConfiguration.volume` 做每Pad音量微调（保持相对平衡）

验收：同样力度下，不同鼓件听感接近；轻打也能触发但不会误触。

### 4. 音色/音乐效果校准（对应的音乐效果）

这里的“音乐效果”建议分三层校准：

- **音色映射层**：鼓件→采样（确保 KICK 触发 bass_drum，SNARE 触发 snare…）
- **混音层**：总音量（`mixerVolume`）+ 每Pad音量（`PadConfiguration.volume`）  
- **效果器层**：混响/延迟（`reverb`/`delay` 或 per-pad 的 effectSettings）

推荐的校准顺序：

- **先关效果器**（reverb/delay 设为 0），把“干声”调平衡  
- 再按风格打开效果器并保存为预设（例如 Rock/Jazz）  
- 为“节拍器”单独校准音量（避免盖过鼓声或听不见）

验收：\n- 不同鼓件的响度合理；\n- 效果器不会导致明显的节奏糊成一团；\n- 在目标BPM下延迟/混响参数不会把节奏推乱。

### 5. 最小校准用例（建议内置一个“校准课程/练习”）

建议内置一个固定pattern用于快速验收：

- 4/4，8分踩镲（42），2/4拍军鼓（38），1/3拍底鼓（36）
- 目标：发声正确 + 打分正确 + 早晚判定符合体感

## 导入后的自动处理

系统会自动：

1. **解析MIDI数据**

   - 提取音符事件、节拍、时间签名
   - 通过GM映射识别鼓件类型（Kick, Snare, Hi-Hat等）

2. **创建课程步骤**

   - 将完整谱面拆分为3个渐进步骤
   - 步骤1：基础模式（前1/3事件）
   - 步骤2：中级模式（前1/2事件）
   - 步骤3：完整模式（所有事件）

3. **自动分析**

   - 计算难度等级（1-5级）
   - 生成标签（如：beginner, rock, jazz等）
   - 检测速度、复杂度、复节奏等特征

4. **保存到数据库**

   - 使用Core Data持久化存储
   - 支持CloudKit同步（如果已配置）

## 课程集创建流程

1. **准备课程**

   - 先导入多个MIDI文件创建课程
   - 或使用已存在的课程

2. **创建课程集**

   - 在 `ContentCreationView` 中点击 "Create Course"
   - 输入课程集信息
   - 选择要包含的课程
   - 系统自动计算课程集难度和标签

## 验证和错误处理

- **内容验证**: 使用 `ContentValidationView` 检查课程完整性
- **错误提示**: 导入失败时会显示具体错误信息
- **警告信息**: 对可能的问题（如缺少描述、标签等）给出警告

## 相关文件

- `ContentManager.swift` - 核心导入逻辑
- `ContentCreationView.swift` - 用户界面
- `ContentBrowserView.swift` - 内容浏览界面
- `MIDIParser.swift` - MIDI文件解析器